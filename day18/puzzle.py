"""day 18"""import numpy as npimport syssys.setrecursionlimit(100000)def add_tuple(a, b):    return (a[0] + b[0], a[1] + b[1])def box_idx(pos):    """    Get list with indices of square box around pos    """    return (add_tuple(pos, (-1, -1)),            add_tuple(pos, (-1, 0)),            add_tuple(pos, (-1, 1)),            add_tuple(pos, (0, -1)),            add_tuple(pos, (0, 1)),            add_tuple(pos, (1, -1)),            add_tuple(pos, (1, 0)),            add_tuple(pos, (1, 1)))def save_grid(grid):    """    Save grid as plain text with 0 and 1    """    chars = {1:'0', 0:'.'}    f = open('grid.txt', 'w')    for i in range(grid.shape[0]):        for k in range(grid.shape[1]):            f.write(chars[grid[i, k]])        f.write('\n')    f.close()def fill(pos, grid):    """    recursively fill area surrounded by ones in an otherwise zero-array    -> works only with increased max recursion depth (100000 is ok)    """    for i in box_idx(pos):        if grid[i] == 0:            grid[i] = 1            fill(i, grid)def fill_2(grid):    """    Fill grid linewise from top left to bottom right - not working yet    """    for i in range(grid.shape[0]):        ones = grid[i, :].nonzero()[0]        for k in range(len(ones)-1):            delta = ones[k+1] - ones[k]            do_fill = False            if delta > 1:                if do_fill:                    for j in range(delta):                        grid[i, ones[k] + j] = 1directions = {'U': (-1,  0),              'D': ( 1,  0),              'R': ( 0,  1),              'L': ( 0, -1)}fid = open('input.txt')lines = fid.readlines()# obtain max dimensions of grid_w = 0width_min = 0width_max = 0_h = 0height_min = 0height_max = 0steps = list()for i in lines:    d, n, col = i.strip().split(' ')    n = int(n)    steps.append((d, n))    if d == 'R':        _w += n    elif d == 'L':        _w -= n    elif d == 'D':        _h += n    elif d == 'U':        _h -= n    width_min = min(_w, width_min)    width_max = max(_w, width_max)    height_min = min(_h, height_min)    height_max = max(_h, height_max)# now 'draw' trench on gridgrid = np.zeros((height_max - height_min + 1, width_max - width_min + 1), dtype=int)pos = (-height_min, -width_min)for d, n in steps:    for k in range(n):        grid[pos] = 1        pos = add_tuple(pos, directions[d])# fill trench#pos = (1, 1)        # input_minpos = (100, 100)    # inputfill(pos, grid)p1 = len(grid.flatten().nonzero()[0])print('result part 1', p1)#save_grid(grid)