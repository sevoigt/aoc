"""day 19"""from functools import partialclass Workflow(object):    def __init__(self, name):        self.name = name        self.steps = list()        self.last = None    def process(self, part):        for cat, func, nxt in self.steps:            if func(part[cat]):                return nxt        return self.lastclass Node(object):    def __init__(self, name):        self.name = name        self.parent = None        self.children = list()        self.condition = None    def __repr__(self):        return f'<Node: {self.name}>'def gt(a, b):    return a > bdef lt(a, b):    return a < bfid = open('input_min.txt')workflows, parts = fid.read().split('\n\n')workflows = workflows.split('\n')parts = parts.split('\n')# prepare workflow data structurewf = dict()for i in workflows:    name, st = i.split('{')    w = Workflow(name)    st = st[:-1].split(',')    w.last = st[-1]    for s in st[:-1]:        cat = s[0]        val, nxt = s.split(':')        val = int(val[2:])        if s[1] == '>':            func = partial(gt, b=val)        elif s[1] == '<':            func = partial(lt, b=val)        else:            raise ValueError('unknown: ', s[1])        w.steps.append((cat, func, nxt))    wf.update({name: w})# prepare parts data structureprt = []for i in parts:    p = {'sum': 0}    for k in i[1:-1].split(','):        key, val = k.split('=')        val = int(val)        p.update({key: val})        p['sum'] += val    prt.append(p)# part 1p1 = 0for p in prt:    pp = wf['in'].process(p)    while pp not in ('R', 'A'):        pp = wf[pp].process(p)    if pp == 'A':        p1 += p['sum']print('result part 1', p1)# part 2end_nodes = list()def populate(node):    """    Build a graph with all possible routes to an accepted node ('A')    """    for i in wf[node.name].steps:        new_node = Node(i[2])        new_node.condition = i[:2]        node.children.append(new_node)        for k in node.children:            k.parent = node            if k.name not in ('R', 'A'):                populate(k)            elif k.name == 'A':                end_nodes.append(k)def get_node_path(node):    """    Get list of nodes to reach targt node from start node    """    path = list()    while node:        path.append(node)        node = node.parent    return path[::-1]def get_conditions(node):    node_path = get_node_path(node)    return [i.condition for i in node_path]# add last step to steps nowfor i in wf.values():    i.steps.append((None, None, i.last))start = Node('in')populate(start)