"""day 19"""from functools import partialclass Workflow(object):    def __init__(self, name):        self.name = name        self.steps = list()        self.last = None    def process(self, part):        for cat, func, nxt in self.steps:            if func(part[cat]):                return nxt        return self.lastclass Node(object):    def __init__(self, name, parent=None):        self.name = name        self.parent = parent        self.children = list()        self.condition = None    def __repr__(self):        cond = '-' if self.condition is None else int(self.condition[0])        return f'<Node: {self.name} ({cond})>'class Part(object):    def __init__(self):        self.data = {'x': (1, 4000),                     'm': (1, 4000),                     'a': (1, 4000),                     's': (1, 4000)}    def apply_condition(self, condition):        if condition is None:            return        cond_true = condition[0]        cat = condition[1]        val = condition[2].keywords['b']        greater = condition[2].func == gt        _min, _max = self.data[cat]        if cond_true and greater:            _min = max(_min, val) + 1        elif cond_true and not greater:            _max = min(_max, val) - 1        elif not cond_true and greater:            _max = min(_max, val)        elif not cond_true and not greater:            _min = max(_min, val)        self.data[cat] = (_min, _max)    def variants(self):        var = 1        for i in self.data.values():            var *= i[1] - i[0] + 1        return vardef gt(a, b):    return a > bdef lt(a, b):    return a < bfid = open('input.txt')workflows, parts = fid.read().split('\n\n')workflows = workflows.split('\n')parts = parts.split('\n')# prepare workflow data structurewf = dict()for i in workflows:    name, st = i.split('{')    w = Workflow(name)    st = st[:-1].split(',')    w.last = st[-1]    for s in st[:-1]:        cat = s[0]        val, nxt = s.split(':')        val = int(val[2:])        if s[1] == '>':            func = partial(gt, b=val)        elif s[1] == '<':            func = partial(lt, b=val)        else:            raise ValueError('unknown: ', s[1])        w.steps.append((cat, func, nxt))    wf.update({name: w})# prepare parts data structureprt = []for i in parts:    p = {'sum': 0}    for k in i[1:-1].split(','):        key, val = k.split('=')        val = int(val)        p.update({key: val})        p['sum'] += val    prt.append(p)# part 1p1 = 0for p in prt:    pp = wf['in'].process(p)    while pp not in ('R', 'A'):        pp = wf[pp].process(p)    if pp == 'A':        p1 += p['sum']print('result part 1:', p1)# part 2end_nodes = list()def populate(node):    """    Build a graph with all possible routes to a terminate node ('A' or 'R')    """    for i in wf[node.name].steps:        # has a condition        if i[1]:            n1 = Node(i[2], node)            n2 = Node(i[2], node)            node.children.append(n1)            node.children.append(n2)            n1.condition = (True, i[0], i[1])   # switch to other workflow            n2.condition = (False, i[0], i[1])  # continue to next step            node = n2            if n1.name not in ('A', 'R'):                populate(n1)        # last step, no condition        else:            n = Node(i[2], node)            node.children.append(n)            n.condition = None            if n.name not in ('A', 'R'):                populate(n)def find_accepted(node):    """    Find all accepted nodes in the graph    end_nodes is a list in the module's namespace    """    if node.name == 'A':        if node.condition is None:            end_nodes.append(node)            return        elif node.condition[0] is True:            end_nodes.append(node)            return    for i in node.children:        find_accepted(i)def get_node_path(node):    """    Get list of nodes to reach targt node from start node    """    path = list()    while node:        path.append(node)        node = node.parent    return path[::-1]def get_conditions(node):    """    Get list of conditions from start to target node    """    node_path = get_node_path(node)    return [i.condition for i in node_path]# add last step to workflow-steps nowfor i in wf.values():    i.steps.append((None, None, i.last))start = Node('in')populate(start)find_accepted(start)p2 = 0for i in end_nodes:    prt = Part()    conditions = get_conditions(i)    for c in conditions:        prt.apply_condition(c)    p2 += prt.variants()print('result part 2:', p2)